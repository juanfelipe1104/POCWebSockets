<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Autenticar con Passkey</title>
  <style>
    body { font-family: system-ui, Arial, sans-serif; max-width: 720px; margin: 40px auto; padding: 0 16px; }
    .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; margin: 16px 0; }
    button { padding: 12px 16px; border-radius: 10px; border: 0; cursor: pointer; background: #111; color: #fff; font-size: 16px; }
    button:disabled { opacity: .6; cursor: not-allowed; }
    pre { background: #0b1020; color: #d6e3ff; padding: 12px; border-radius: 12px; overflow:auto; }
    .ok { color: #0a7a2f; font-weight: 700; }
    .err { color: #b00020; font-weight: 700; }
  </style>
</head>
<body>
  <h1>Autenticar con Passkey</h1>

  <div class="card">
    <button id="btnAuth">Autenticar</button>
    <div id="status" style="margin-top:12px;"></div>
  </div>

  <div class="card">
    <pre id="log"></pre>
  </div>

<script>
  // ==========================
  // CONFIG (hardcode)
  // ==========================
  // URL A: Begin Authentication (username-first). Debe devolver publicKey options con allowCredentials
  const BEGIN_AUTH_URL  = "https://TU_DOMINIO.com/beginAuthentication";
  // URL B: Finish Authentication. Recibe assertion y valida firma con tu Lambda/Backend
  const FINISH_AUTH_URL = "https://TU_DOMINIO.com/finishAuthentication";

  // Headers requeridos
  const X_TRANSACTION  = "TX-CLIENT-STATIC-001"; // puedes generar uno por intento si quieres
  const X_COMPONENT_ID = "authenticatepasskey-ui";

  // Body para begin auth (username-first): tu backend debe conocer el usuario.
  // Si tu backend lo infiere por sesión/cookie, puedes dejar {}.
  const BEGIN_BODY = {
    // username: "alba@correo.com"
  };

  // ==========================
  // Base64URL helpers
  // ==========================
  function base64urlToArrayBuffer(b64url) {
    const padding = "=".repeat((4 - (b64url.length % 4)) % 4);
    const b64 = (b64url + padding).replace(/-/g, "+").replace(/_/g, "/");
    const raw = atob(b64);
    const bytes = new Uint8Array(raw.length);
    for (let i = 0; i < raw.length; i++) bytes[i] = raw.charCodeAt(i);
    return bytes.buffer;
  }

  function arrayBufferToBase64url(buffer) {
    const bytes = new Uint8Array(buffer);
    let s = "";
    for (const b of bytes) s += String.fromCharCode(b);
    return btoa(s).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/g, "");
  }

  // ==========================
  // UI helpers
  // ==========================
  const $ = (id) => document.getElementById(id);
  const logEl = $("log");
  const statusEl = $("status");

  function setStatus(text, kind) {
    statusEl.innerHTML = `<p class="${kind === "ok" ? "ok" : kind === "err" ? "err" : ""}">${text}</p>`;
  }

  function log(...args) {
    const msg = args.map(a => (typeof a === "string" ? a : JSON.stringify(a, null, 2))).join(" ");
    logEl.textContent += msg + "\n";
    logEl.scrollTop = logEl.scrollHeight;
  }

  function clearLog() {
    logEl.textContent = "";
    statusEl.textContent = "";
  }

  // ==========================
  // HTTP helper (adds headers)
  // ==========================
  async function postJson(url, body) {
    const res = await fetch(url, {
      method: "POST",
      headers: {
        "content-type": "application/json",
        "X-Transaction": X_TRANSACTION,
        "X-ComponentId": X_COMPONENT_ID
      },
      body: JSON.stringify(body ?? {})
    });

    const txt = await res.text();
    let json;
    try { json = JSON.parse(txt); } catch { json = { raw: txt }; }

    if (!res.ok) {
      const err = new Error(`HTTP ${res.status}`);
      err.details = json;
      throw err;
    }
    return json;
  }

  // ==========================
  // Normalize request options
  // ==========================
  function normalizeRequestOptions(publicKeyFromServer) {
    // Se asume que el servidor devuelve:
    // publicKey.challenge: base64url
    // allowCredentials[].id: base64url (si viene)
    const pk = structuredClone(publicKeyFromServer);

    pk.challenge = base64urlToArrayBuffer(pk.challenge);

    if (Array.isArray(pk.allowCredentials)) {
      pk.allowCredentials = pk.allowCredentials.map(c => ({
        ...c,
        id: base64urlToArrayBuffer(c.id)
      }));
    }

    return pk;
  }

  // ==========================
  // Build finish auth payload
  // ==========================
  function buildFinishAuthenticationPayload(assertion) {
    return {
      id: assertion.id,
      rawId: arrayBufferToBase64url(assertion.rawId),
      type: assertion.type,
      response: {
        clientDataJSON: arrayBufferToBase64url(assertion.response.clientDataJSON),
        authenticatorData: arrayBufferToBase64url(assertion.response.authenticatorData),
        signature: arrayBufferToBase64url(assertion.response.signature),
        userHandle: assertion.response.userHandle
          ? arrayBufferToBase64url(assertion.response.userHandle)
          : null
      }
    };
  }

  // ==========================
  // Main flow
  // ==========================
  async function authenticatePasskey() {
    clearLog();

    if (!window.PublicKeyCredential || !navigator.credentials) {
      setStatus("Este navegador no soporta WebAuthn.", "err");
      return;
    }

    $("btnAuth").disabled = true;

    try {
      setStatus("1) Solicitando options al servidor (Begin Authentication)...", "");
      log("POST", BEGIN_AUTH_URL);

      // Begin Authentication (username-first)
      const beginResponse = await postJson(BEGIN_AUTH_URL, BEGIN_BODY);
      log("Begin response:", beginResponse);

      // Se espera: { publicKey }
      const publicKeyFromServer = beginResponse.publicKey;
      if (!publicKeyFromServer) throw new Error("BeginAuthentication no devolvió publicKey");

      setStatus("2) Autenticando con passkey (WebAuthn get)...", "");
      const publicKey = normalizeRequestOptions(publicKeyFromServer);

      const assertion = await navigator.credentials.get({ publicKey });
      if (!assertion) throw new Error("navigator.credentials.get devolvió null");

      log("Assertion obtained. id =", assertion.id);

      setStatus("3) Enviando assertion al servidor (Finish Authentication)...", "");
      const finishPayload = buildFinishAuthenticationPayload(assertion);

      log("POST", FINISH_AUTH_URL);
      log("Finish payload:", finishPayload);

      const finishResponse = await postJson(FINISH_AUTH_URL, finishPayload);
      log("Finish response:", finishResponse);

      if (finishResponse.code === 200) {
        setStatus("✅ Autenticación exitosa.", "ok");
      } else {
        setStatus(`❌ Error del servidor: ${finishResponse.message}`, "err");
      }

    } catch (e) {
      console.error(e);
      setStatus(`❌ Error: ${e.message}`, "err");
      if (e.details) log("Detalles:", e.details);
      else log("Detalles:", String(e));
    } finally {
      $("btnAuth").disabled = false;
    }
  }

  $("btnAuth").addEventListener("click", authenticatePasskey);
</script>
</body>
</html>
